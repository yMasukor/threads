<!doctype html>
<html>
	<head>
	<script src="lib/jquery-2.1.3.min.js"></script>
	<script src="lib/tween.min.js"></script>
    <script src="lib/tsw.js"></script>
    <script src="lib/underscore.js"></script>
	<script src="lib/paper-full.js"></script>



	
	<script src="https://cdn.socket.io/socket.io-1.3.3.js"></script>

	
	<script src="audio.js"></script>

	<script src="CuePoint.js"></script>
	<script src="Threads.js"></script>
	<script src="Player.js"></script>
	<script src="backgroundLayer.js"></script>
<!--    
    <script src="metronome.js"></script>
    <script src="animations.js"></script> -->
    

    <script src="states/themes.js"></script>
    <script src="states/state-two.js"></script>
	<script src="states/state-one.js"></script>


	
	<style type="text/css">
		*{
			margin: 0px;
			padding: 0px;
		}

		canvas{
			position: absolute;
			top: 0px;
			left: 0px;
			right: 0px;
			bottom: 0px;
		}

	</style>



	</head>
	<body>


	<canvas id="myCanvas" resize keepalive="true" ></canvas>


	<script type="text/javascript">



		


		
	</script>


	<script type="text/javascript" >

		paper.install(window);

		var TWO_PI = Math.PI * 2;

		

		var players = {},
		loopDuration = 120000,
		barsPerLoop = 4,
		beatsPerBar = 4,
		ticksPerBeat = 4,
		tickDuration = ((loopDuration/barsPerLoop)/beatsPerBar)/ticksPerBeat,
		duration = tickDuration*ticksPerBeat,


		socket = io(),

		backingTrack = {
			playing:false,
		},

		// this.themes = themes
		// this.states = [stateTwo]
		// this.state = this.states[0]

		samples,
		backgroundTextures,
		triggerables,
		vocals,
		beatCount,
		threadDraws,
		threadComplete,
		threadEnds

			
		


		var state = stateTwo,
		samplesLoaded = false;

		


		var background;
		
		var complexity = {
			level:0
		}



		
		Object.observe(complexity, function(changes){
			
			updateBackingTrack();


			if(visualiser)
				visualiser.changeSaturation();

		});

	


		

        
		


		$(document).ready(function(){

			
			paper.setup('myCanvas')

			console.log('PAPER IS', paper)
			var tool = new Tool();
			loadAudio();

			//connect to the server
			socket.emit('connectViewer');

			socket.on('connected', function(existingPlayers){
				existingPlayers.forEach(function(playerId){
					addPlayer(playerId);
				});

				console.log('viewer connected, existing players', players, existingPlayers);
			});



			//add player when they connect
			socket.on('addPlayer', function(playerId){
				console.log('player connected');
				addPlayer(playerId);
			});


			socket.on('removePlayer', function(playerId){
				players[playerId].thread.state = 'playing';
				players[playerId].thread.state.lifespan = 0;
				players[playerId].thread.state.willAnimateOut = true;
				players[playerId].thread.onReset = function(){
					delete players[playerId]
				}
				// 
			});

			//recieve player input
			socket.on('playerUpdate', function(input){

				
				var e = {}
				e.tool = tool;

				// console.log('update', input.delta)

				e.point = new Point(input.point.x*view.bounds.width, input.point.y*view.bounds.height);
				e.delta = new Point(input.delta.x*view.bounds.width, input.delta.y*view.bounds.height);
				
				// console.log('update post scale', input.delta)

				if(input.type == 'mousedown'){
					players[input.id].dragStart(e);
				}else if(input.type == 'mousedrag'){
					players[input.id].drag(e);
				}else if(input.type == 'mouseup'){
					players[input.id].dragEnd(e);
				}else if(input.type == 'cuepoint'){
					console.log('cuepoint recieved')
					// players[input.id].thread.pushPoint(e);
					players[input.id].thread.createCuepoint();
				}
			});



			//Listen for tick
			socket.on('tick', function(tickCount){
				// console.log('tick', tickCount);


				if(tickCount == 0 && !backingTrack.playing){
					playBackingTrack();
				}

				if(tickCount == 0 && complexity.level == 0 && backingTrack.playing){
					if( Math.floor(Math.random()*3) == 0){
						backingTrack.chords.gainNode.gain(0)
						backingTrack.drums1.gainNode.gain(1)
					}else{
						backingTrack.chords.gainNode.gain(1)
						backingTrack.drums1.gainNode.gain(0)
					}
				}

				if(complexity.level > 1){
					if(Math.floor(Math.random()*16) == 0){
						vocals[Math.floor(Math.random()*vocals.length)].play();
					}
				}


				_.each(players, function(player){
					player.thread.triggerCuePoints(tickCount)
				});


				if(Math.floor(Math.random()*16) == 0){
					backgroundTextures[Math.floor(Math.random()*backgroundTextures.length)].play();
				}

				analyser.getByteTimeDomainData(dataArray);

			});













			
			visualiser.create();





			view.onFrame = function(e) {
				_.each(players, function(player){
					player.thread.update(e);
				});

				TWEEN.update();
				visualiser.update();	
				
			}

		});


		function addPlayer(playerId){
			var playerCount = _.size(players)
			if(playerCount < 2){
				console.log('adding player', playerId);

				var player = new Player(playerId, playerCount);
				players[playerId] = player;
			}else{
				console.log('both players connected');
			}
		}






		function setState(newState){

			state = newState;
			//update background color
			// animations['horizontalWipe'].start(state.theme.back);


			//update 
		}




		

	</script>

	


	
	
	





	</body>
</html>