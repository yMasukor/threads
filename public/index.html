<!doctype html>
<html>
	<head>
	<script src="lib/jquery-2.1.3.min.js"></script>
	<script src="lib/tween.min.js"></script>
    <script src="lib/tsw.js"></script>
    <script src="lib/underscore.js"></script>
	<script src="lib/paper-full.js"></script>



	
	<script src="https://cdn.socket.io/socket.io-1.3.3.js"></script>

	
	<script src="audio.js"></script>

	<script src="CuePoint.js"></script>
	<script src="Thread.js"></script>
	<script src="Player.js"></script>
	<script src="backgroundLayer.js"></script>
<!--    
    <script src="metronome.js"></script>
    <script src="animations.js"></script> -->
    

    <script src="states/themes.js"></script>
    <script src="states/state-two.js"></script>
	<script src="states/state-one.js"></script>


	
	<style type="text/css">
	*{
		margin: 0px;
		padding: 0px;
	}

	canvas{
		position: absolute;
		top: 0px;
		left: 0px;
		right: 0px;
		bottom: 0px;
	}

	</style>



	</head>
	<body>


	<canvas id="myCanvas" resize keepalive="true" ></canvas>


	<script type="text/javascript">



		


		
	</script>


	<script type="text/javascript" >

		paper.install(window);

		var TWO_PI = Math.PI * 2;

		

		var players = {},
		loopDuration = 120000,
		barsPerLoop = 4,
		beatsPerBar = 4,
		ticksPerBeat = 4,
		tickDuration = ((loopDuration/barsPerLoop)/beatsPerBar)/ticksPerBeat,
		duration = tickDuration*ticksPerBeat,


		socket = io(),

		backingTrack = {
			playing:false,
		},

		// this.themes = themes
		// this.states = [stateTwo]
		// this.state = this.states[0]

		samples,
		backgroundTextures,
		triggerables,
		vocals,
		beatCount

			
		


		var state = stateTwo,
		samplesLoaded = false;

		


		var background;




		





		

        
		


		$(document).ready(function(){

			
			paper.setup('myCanvas')
			var tool = new Tool();
			loadAudio();

			//connect to the server
			socket.emit('connectViewer');

			socket.on('connected', function(existingPlayers){
				existingPlayers.forEach(function(playerId){
					addPlayer(playerId);
				});

				console.log('viewer connected, existing players', players, existingPlayers);
			});



			//add player when they connect
			socket.on('addPlayer', function(playerId){
				console.log('player connected');
				addPlayer(playerId);
			});


			socket.on('removePlayer', function(playerId){
				delete players[playerId]
			});

			//recieve player input
			socket.on('playerUpdate', function(input){

				console.log('update', input)
				input.tool = tool;

				input.point = new Point(input.point.x*view.bounds.width, input.point.y*view.bounds.height);
				input.delta = new Point(input.delta.x*view.bounds.width, input.delta.y*view.bounds.height);
				
				

				if(input.type == 'mousedown'){
					players[input.id].dragStart(input);
				}else if(input.type == 'mousedrag'){
					players[input.id].drag(input);
				}else if(input.type == 'mouseup'){
					players[input.id].dragEnd(input);
				}
			});



			//Listen for tick
			socket.on('tick', function(tickCount){
				// console.log('tick', tickCount);


				if(tickCount == 0 && !backingTrack.playing){
					playBackingTrack();
				}


				_.each(players, function(player){
					player.thread.triggerCuePoints(tickCount)
				});


				if(Math.floor(Math.random()*16) == 0){
					backgroundTextures[Math.floor(Math.random()*backgroundTextures.length)].play();
				}

				analyser.getByteTimeDomainData(dataArray);

			});













			background = new Shape.Rectangle(new Point(0,0), view.size);
			background.fillColor = '#84FFFF';
			visualiser.create();





			view.onFrame = function(e) {
				_.each(players, function(player){
					player.thread.update(e);
				});

				TWEEN.update();


				visualiser.update();

				
				
			}





			// DEBUG PLAYER\

			// window.setTimeout(function(){
			// 	
			// }, 1000)
			

            // addPlayer('foobar');

			tool.onMouseDown =  function(e) {
				players['foobar'].dragStart(e);
			}

			tool.onMouseDrag =  function(e) {
				players['foobar'].drag(e);
			}

			tool.onMouseUp =  function(e) {
				players['foobar'].dragEnd(e);
			}


		});


		// var backgroundVisualiser;

		// function makeBackground(){

		// 	// 
		// 	// 
		// 	// var points = [new Two.Anchor(width, 0), new Two.Anchor(0, 0)];

			



		// }








		function addPlayer(playerId){
			var playerCount = _.size(players)
			if(playerCount < 2){
				console.log('adding player', playerId);

				var player = new Player(playerId, playerCount);
				players[playerId] = player;
			}else{
				console.log('both players connected');
			}
		}






		function setState(newState){

			state = newState;
			//update background color
			// animations['horizontalWipe'].start(state.theme.back);


			//update 
		}




		

	</script>

	


	
	
	





	</body>
</html>