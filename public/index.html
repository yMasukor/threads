<!doctype html>
<html>
	<head>
	<script src="lib/jquery-2.1.3.min.js"></script>
	<script src="lib/tween.min.js"></script>
    <script src="lib/tsw.js"></script>
    <script src="lib/underscore.js"></script>
	<script src="lib/paper-full.js"></script>



	
	<script src="https://cdn.socket.io/socket.io-1.3.3.js"></script>

	
	<script src="audio.js"></script>

	<script src="CuePoint.js"></script>
	<script src="Thread.js"></script>
	<script src="Player.js"></script>
	<script src="backgroundLayer.js"></script>
<!--    
    <script src="metronome.js"></script>
    <script src="animations.js"></script> -->
    

    <script src="states/themes.js"></script>
    <script src="states/state-two.js"></script>
	<script src="states/state-one.js"></script>


	
	<style type="text/css">
		*{
			margin: 0px;
			padding: 0px;
		}

		canvas{
			position: absolute;
			top: 0px;
			left: 0px;
			right: 0px;
			bottom: 0px;
		}

	</style>



	</head>
	<body>


	<canvas id="myCanvas" resize keepalive="true" ></canvas>


	<script type="text/javascript">



		


		
	</script>


	<script type="text/javascript" >

		paper.install(window);

		var TWO_PI = Math.PI * 2;

		

		var players = {},
		loopDuration = 120000,
		barsPerLoop = 4,
		beatsPerBar = 4,
		ticksPerBeat = 4,
		tickDuration = ((loopDuration/barsPerLoop)/beatsPerBar)/ticksPerBeat,
		duration = tickDuration*ticksPerBeat,


		socket = io(),

		backingTrack = {
			playing:false,
		},

		// this.themes = themes
		// this.states = [stateTwo]
		// this.state = this.states[0]

		samples,
		backgroundTextures,
		triggerables,
		vocals,
		beatCount

			
		


		var state = stateTwo,
		samplesLoaded = false;

		


		var background;




		





		

        
		


		$(document).ready(function(){

			
			paper.setup('myCanvas')

			console.log('PAPER IS', paper)
			var tool = new Tool();
			loadAudio();

			//connect to the server
			socket.emit('connectViewer');

			socket.on('connected', function(existingPlayers){
				existingPlayers.forEach(function(playerId){
					addPlayer(playerId);
				});

				console.log('viewer connected, existing players', players, existingPlayers);
			});



			//add player when they connect
			socket.on('addPlayer', function(playerId){
				console.log('player connected');
				addPlayer(playerId);
			});


			socket.on('removePlayer', function(playerId){
				players[playerId].thread.state = 'playing';
				players[playerId].thread.state.lifespan = 0;
				players[playerId].thread.state.willAnimateOut = true;
				players[playerId].thread.onReset = function(){
					delete players[playerId]
				}
				// 
			});

			//recieve player input
			socket.on('playerUpdate', function(input){

				
				var e = {}
				e.tool = tool;

				// console.log('update', input.delta)

				e.point = new Point(input.point.x*view.bounds.width, input.point.y*view.bounds.height);
				e.delta = new Point(input.delta.x*view.bounds.width, input.delta.y*view.bounds.height);
				
				// console.log('update post scale', input.delta)

				if(input.type == 'mousedown'){
					players[input.id].dragStart(e);
				}else if(input.type == 'mousedrag'){
					players[input.id].drag(e);
				}else if(input.type == 'mouseup'){
					players[input.id].dragEnd(e);
				}else if(input.type == 'cuepoint'){
					console.log('cuepoint recieved')
					// players[input.id].thread.pushPoint(e);
					players[input.id].thread.createCuepoint();
				}
			});



			//Listen for tick
			socket.on('tick', function(tickCount){
				// console.log('tick', tickCount);


				if(tickCount == 0 && !backingTrack.playing){
					playBackingTrack();
				}


				_.each(players, function(player){
					player.thread.triggerCuePoints(tickCount)
				});


				if(Math.floor(Math.random()*16) == 0){
					backgroundTextures[Math.floor(Math.random()*backgroundTextures.length)].play();
				}

				analyser.getByteTimeDomainData(dataArray);

			});













			background = new Shape.Rectangle(new Point(0,0), view.size);
			background.fillColor = '#84FFFF';
			visualiser.create();





			view.onFrame = function(e) {
				_.each(players, function(player){
					player.thread.update(e);
				});

				TWEEN.update();


				visualiser.update();

				
				
			}





			// DEBUG PLAYER\

			// window.setTimeout(function(){
			// 	
			// }, 1000)
			

            // addPlayer('foobar');

			tool.onMouseDown =  function(e) {
				players['foobar'].dragStart(e);
			}

			tool.onMouseDrag =  function(e) {
				players['foobar'].drag(e);
			}

			tool.onMouseUp =  function(e) {
				players['foobar'].dragEnd(e);
			}


		});


		// var backgroundVisualiser;

		// function makeBackground(){

		// 	// 
		// 	// 
		// 	// var points = [new Two.Anchor(width, 0), new Two.Anchor(0, 0)];

			



		// }








		function addPlayer(playerId){
			var playerCount = _.size(players)
			if(playerCount < 2){
				console.log('adding player', playerId);

				var player = new Player(playerId, playerCount);
				players[playerId] = player;
			}else{
				console.log('both players connected');
			}
		}






		function setState(newState){

			state = newState;
			//update background color
			// animations['horizontalWipe'].start(state.theme.back);


			//update 
		}




		

	</script>

	


	
	
	





	</body>
</html>