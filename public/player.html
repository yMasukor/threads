<!DOCTYPE HTML>
<html>
<head>
    <title></title>

    <meta name="mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=1280">

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #263238;
        }

        canvas{
            position: absolute;
            top: 0px;
            left: 0px;
            right: 0px;
            bottom:0px;
            margin: auto;
        }
    </style>

    <script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
    <script src="http://code.jquery.com/jquery-1.11.1.js"></script>
    <script src="phaser.min.js"></script>

</head>
<body>
    <script type="text/javascript">
        
    var socket = io();

    var playerID;
    var stepCount = 16;
    var stepWidth;



    var colors = [
        '0xF44336',
        '0xE91E63',
        '0x2196F3',
        '0x4CAF50',
        '0xFF5722'
    ]

    var game = new Phaser.Game(1280, 720, Phaser.AUTO, '', { preload: preload, create: create, update: update, render: render });


    //

    socket.on('joined', function(id){
        playerID = id;
        console.log('my id is', playerID);
        states.update('passive');
    });

    socket.on('createNewBar', function(bar){
        console.log('creating new bar', bar);
        if(states.state != 'inactive' && !bar.complete){
            states.update('active');
        }
        currentBar.display(bar, null);
    });

    socket.on('wait', function(){
        states.update('passive');
    });

    socket.on('complete', function(){
        states.update('complete');
    });

    socket.on('stop', function(){
        states.update('inactive');
    });



    var states = {
        state:'inactive',
        passiveState:null,
        activeState:null,
        inactiveState:null,
        completeState:null,


        createStates:function(){

            this.activeState = game.add.sprite(0,10,'');


            var textStyle = { font: "72px Arial", fill: "#FFFFFF", align: "center" };


            //Passive state
            this.passiveState = game.add.sprite(0,10,'');
            this.passiveState.alpha = 0;

            //draw it's background
            var passiveBackground = game.add.graphics(0,0);
            this.passiveState.addChild(passiveBackground);
            passiveBackground.beginFill('0x000000');
            passiveBackground.drawRect(0,0,game.stage.width, game.stage.height);

            var passiveText = game.add.text(48, 200, 'WAIT', textStyle);
            this.passiveState.addChild(passiveText);


            //Inactive state
            this.inactiveState = game.add.sprite(0,10,'');
            this.inactiveState.alpha = 0;

            //draw it's background
            var inactiveBackground = game.add.graphics(0,0);
            this.inactiveState.addChild(inactiveBackground);
            inactiveBackground.beginFill('0x000000');
            inactiveBackground.drawRect(0,0,game.stage.width, game.stage.height);

            var inactiveText = game.add.text(48, 200, 'TOUCH TO START', textStyle);
            this.inactiveState.addChild(inactiveText);



            //Complete state
            this.completeState = game.add.sprite(0,10,'');
            this.completeState.alpha = 0;

            //draw it's background
            var completeBackground = game.add.graphics(0,0);
            this.completeState.addChild(completeBackground);
            completeBackground.beginFill('0x000000');
            completeBackground.drawRect(0,0,game.stage.width, game.stage.height);

            var completeText = game.add.text(48, 200, 'TRACK COMPLETE', textStyle);
            this.completeState.addChild(completeText);
        },

        update:function(state){
            this.state = state;

            if(this.state == 'active'){
                var hidePassive = game.add.tween(this.passiveState).to( { alpha: 0 }, 200, Phaser.Easing.Linear.None, true, 0, 0, false);
                var hideInactive = game.add.tween(this.inactiveState).to( { alpha: 0 }, 200, Phaser.Easing.Linear.None, true, 0, 0, false);
                var hideComplete = game.add.tween(this.inactiveState).to( { alpha: 0 }, 200, Phaser.Easing.Linear.None, true, 0, 0, false);

            }else if(this.state == 'passive'){
                var showPassive = game.add.tween(this.passiveState).to( { alpha: 0.6 }, 200, Phaser.Easing.Linear.None, true, 0, 0, false);
                var hideInactive = game.add.tween(this.inactiveState).to( { alpha: 0 }, 200, Phaser.Easing.Linear.None, true, 0, 0, false);
                var hideComplete = game.add.tween(this.completeState).to( { alpha: 0 }, 200, Phaser.Easing.Linear.None, true, 0, 0, false);

            }else if(this.state == 'inactive'){
                var hidePassive = game.add.tween(this.passiveState).to( { alpha: 0 }, 200, Phaser.Easing.Linear.None, true, 0, 0, false);
                var showInactive = game.add.tween(this.inactiveState).to( { alpha: 1 }, 200, Phaser.Easing.Linear.None, true, 0, 0, false);
                var hideComplete = game.add.tween(this.completeState).to( { alpha: 0 }, 200, Phaser.Easing.Linear.None, true, 0, 0, false);

            }else if(this.state == 'complete'){
                var hidePassive = game.add.tween(this.passiveState).to( { alpha: 0 }, 200, Phaser.Easing.Linear.None, true, 0, 0, false);
                var hideInactive = game.add.tween(this.inactiveState).to( { alpha: 0 }, 200, Phaser.Easing.Linear.None, true, 0, 0, false);
                var showComplete = game.add.tween(this.completeState).to( { alpha: 1 }, 200, Phaser.Easing.Linear.None, true, 0, 0, false);
            }
        }
    }



    var currentBar = {
        
        displayMode:0,
        players:{},
        sprite:null,

        display:function(bar, stepData){
            this.displayMode = bar.displayMode;
            this.players = bar.players;

            //create a new sprite for the next bar
            var newBar = game.add.sprite(0,0,'');
            newBar.alpha = 0;

            states.activeState.addChild(newBar);

            //draw it's background
            var background = game.add.graphics(0,0);
            newBar.addChild(background);
            background.beginFill(colors[this.displayMode]);
            background.drawRect(0,0,game.stage.width, game.stage.height);


            if(stepData != null){
                this.populate(stepData)
            }


            var showBar = game.add.tween(newBar).to( { alpha: 1 }, 200, Phaser.Easing.Linear.None, true, 0, 0, false);

            showBar.onComplete.add(function(target){
                if(this.sprite){
                    this.sprite.destroy(true);
                }
                this.sprite = target;
            }.bind(this));
        },

        addStep:function(playerID, step){
            this.players[playerID].steps.push(step);
            this.showStep(step);
            socket.emit('stepAdded', step);
        },
        showStep:function(step){
            var point = game.add.sprite(step.x, step.y, debugPoint);
            this.sprite.addChild(point);
        },

        populate:function(stepData){
            //if we're playing back a bar, populate it with data here
        }
    }



 
    


    var input = {

        lastPos:null,

        init:function(){
            this.lastPos = new Phaser.Point(0, 0)
            // game.input.activePointer.onDown.add(function(){
            //     console.log('sadfsadf')
            //     pointer = game.input.activePointer;
            //     input.down(pointer, pointer.x, pointer.y);
            // });

            game.input.addMoveCallback(input.move, this);

            game.input.onUp.add(function(){
                pointer = game.input.activePointer;
                input.up(pointer, pointer.x, pointer.y);
            });
            
        },


        move:function(pointer, x, y){

            if(pointer.isDown && states.state == 'active'){
                
                if(Math.floor(this.lastPos.x/stepWidth) != Math.floor(x/stepWidth)){
                    var step = {
                        x:x,
                        y:y,
                        stepIndex:Math.floor(x/stepWidth)
                    }
                    currentBar.addStep(playerID, step); 
                }
                
                this.lastPos.setTo(x, y);
            }else if(pointer.isDown && states.state == 'inactive'){
                socket.emit('playerJoined');
            }

        },
        up:function(pointer, x, y){

        }
    }


    var debugPoint;






    function preload() {
        var graphics = new Phaser.Graphics();
        graphics.beginFill(0xFFFFFF);
        graphics.drawCircle(0, 0,10);

        debugPoint = game.add.renderTexture(10, 10, 'foo');
        debugPoint.renderXY(graphics, 5, 5, true);
    }
 
    function create() {

        stepWidth = game.stage.width/stepCount;

        input.init(); 

        states.createStates();
        states.update('inactive');

        metronome.add();
    }



    function update() {

    }







    function render() {


    }



    var metronome = {
        steps:[],

        add:function(){

            var graphics = new Phaser.Graphics();
            graphics.beginFill(0xFF0000);
            graphics.drawRect(0, 0, stepWidth, 10);

            square = game.add.renderTexture(stepWidth, 10, 'tick');
            square.renderXY(graphics, 0, 0, true);

            // metronome.minorTick = game.add.sprite(0,0,square);

            for(var i=0; i<16; i++){

                var step = game.add.sprite(i*stepWidth, 0, square);
                step.visible = false;
                this.steps.push(step);

            }


            socket.on('step', function(currentStep){
                metronome.update(currentStep);
            });
        },

        update:function(currentStep){
            this.steps.forEach(function(step, index){
                if(index == currentStep){
                    step.visible = true;
                }else{
                    step.visible = false;
                }
            });
        }
    }

 
    </script>
 
    </body>
</html>