<!DOCTYPE HTML>
<html>
<head>
    <title></title>

    <meta name="mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=1280">

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #263238;
        }

        canvas{
            position: absolute;
            top: 0px;
            left: 0px;
            right: 0px;
            bottom:0px;
            margin: auto;
        }
    </style>

    <script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
    <script src="http://code.jquery.com/jquery-1.11.1.js"></script>
    <script src="phaser.min.js"></script>

</head>
<body>
    <script type="text/javascript">
        
    var socket = io();

    var stepCount = 16;
    var stepWidth;




    var colors = [
        '0xF44336',
        '0xE91E63',
        '0x2196F3',
        '0x4CAF50',
        '0xFF5722'
    ]

    var game = new Phaser.Game(1280, 720, Phaser.AUTO, '', { preload: preload, create: create, update: update, render: render });


    socket.emit('viewerJoined');

    socket.on('joined', function(id){
        playerID = id;
        console.log('my id is', playerID);
    });

    socket.on('createNewBar', function(bar){
        console.log('creating new bar', bar);
        currentBar.display(bar, null);
    });

    socket.on('playBar', function(bar){
        currentBar.display(bar, true);
    });

    socket.on('partialBar', function(bar){
        currentBar.display(bar, true);
    });

    socket.on('addStep', function(step){
        currentBar.addStep(step.playerID, step);
    });

    socket.on('addPlayer', function(player){
        currentBar.addPlayer(player);
    });



    var inputState = {
        state:'inactive',
        update:function(state){
            this.state = state;

            if(this.state == 'active'){

            }else if(this.state == 'passive'){

            }else if(this.state == 'inactive'){

            }
        }
    }



    var currentBar = {
        
        displayMode:0,
        players:{},
        sprite:null,

        display:function(bar, stepData){
            this.displayMode = bar.displayMode;
            this.players = bar.players;

            //create a new sprite for the next bar
            var newBar = game.add.sprite(0,10,'');
            newBar.alpha = 0;

            //draw it's background
            var background = game.add.graphics(0,0);
            newBar.addChild(background);
            background.beginFill(colors[this.displayMode]);
            background.drawRect(0,0,game.stage.width, game.stage.height);


            


            var showBar = game.add.tween(newBar).to( { alpha: 1 }, 200, Phaser.Easing.Linear.None, true, 0, 0, false);

            showBar.onComplete.add(function(target){
                if(this.sprite){
                    this.sprite.destroy(true);
                }
                this.sprite = target;
                if(stepData == true){
                    this.populate()
                }
            }.bind(this));
        },

        addPlayer:function(player){
            this.players[player.id] = player
        },

        addStep:function(playerID, step){
            this.players[playerID].steps.push(step);
            this.showStep(step);
            //socket.emit('stepAdded', step);
        },
        showStep:function(step){
            var point = game.add.sprite(step.x, step.y, debugPoint);
            this.sprite.addChild(point);
        },

        populate:function(){
            for(id in this.players){

                var player = this.players[id];
                console.log(player);
                player.steps.forEach(function(step){
                    currentBar.showStep(step);
                });

            }
        }
    }



    // var metronome = {};

    // var currentTrack = [];
    // var touchInfo = [];
    // var currentBar = 0;

    // var activeBar;

    // var ball;

    // var stepWidth;

    // var lastX;
    // var points = [];


    // var idleScreen;
    // var waitScreen;
    // var waiting = false;


    // //Inform the server that we're a player;
    // socket.emit('playerConnected', true);

    // //listen for ID assignment
    // socket.on('idAssigned', function(id){
    //     console.log('got an id', id);
    // });

    // socket.on('newTrack', function(){
    //     currentTrack = [];
    //     touchInfo = [];
    //     points = [];

    //     console.log('new track starting')
    // });


    // socket.on('newBar', function(bar){ 
    //     showBar(bar);
    // });

    // socket.on('wait', function(){ 
    //     wait();
    // });





    var debugPoint;






    function preload() {
        var graphics = new Phaser.Graphics();
        graphics.beginFill(0xFFFFFF);
        graphics.drawCircle(0, 0,10);

        debugPoint = game.add.renderTexture(10, 10, 'foo');
        debugPoint.renderXY(graphics, 5, 5, true);
    }
 
    function create() {

        stepWidth = game.stage.width/stepCount;
        metronome.add();
    }



    function update() {

    }







    function render() {


    }







    var metronome = {
        steps:[],

        add:function(){

            var graphics = new Phaser.Graphics();
            graphics.beginFill(0xFF0000);
            graphics.drawRect(0, 0, stepWidth, 10);

            square = game.add.renderTexture(stepWidth, 10, 'tick');
            square.renderXY(graphics, 0, 0, true);

            // metronome.minorTick = game.add.sprite(0,0,square);

            for(var i=0; i<16; i++){

                var step = game.add.sprite(i*stepWidth, 0, square);
                step.visible = false;
                this.steps.push(step);

            }


            socket.on('step', function(currentStep){
                metronome.update(currentStep);
            });
        },

        update:function(currentStep){
            this.steps.forEach(function(step, index){
                if(index == currentStep){
                    step.visible = true;
                }else{
                    step.visible = false;
                }
            });
        }
    }

    // function beginNewTrack(){

    // }

    






    // currentTrack = {
    //     currentBarIndex:0
    //     bars:[
    //         {
    //             index:0,
    //             players:[
    //                 {
    //                     id:playerID,
    //                     complete:false,
    //                     steps:[]
    //                 }
    //             ]
    //         }
    //     ]
    // }




    




    // function showBar(bar){
        
    //     console.log('showing new bar', bar)

    //     game.add.tween(waitScreen).to( { alpha: 0 }, 200, Phaser.Easing.Linear.None, true, 0, 0, false);
    //     waiting = false;





    //     
        
    //     

    // }

    // function loadBar(index){

    // }













    // function pointerDown(pointer, x, y){
    //     console.log('pointer down');
    //     //showBar();

       

    // }

    // function pointerMove(pointer, x, y){

    //     if(pointer.isDown && !waiting){

    //         console.log(Math.floor(lastX/stepWidth), Math.floor(x/stepWidth));
            
    //         if(Math.floor(lastX/stepWidth) != Math.floor(x/stepWidth)){

    //             var step = {
    //                 x:x,
    //                 y:y,
    //                 stepCount:Math.floor(x/stepWidth)
    //             }

    //             points.push(step);
    //             socket.emit('stepAdded', step);

    //             console.log(points);

    //             game.add.sprite(x, y, ball);
    //         }
            
    //         lastX = x;
    //     }
    // }

    // function pointerUp(pointer, x, y){
    //     //console.log(pointerUp)
    // }
   






 
    

    

    // socket.on('step', function(currentStep){
    //     metronome.update(currentStep);
    // });




    // function idle(){

    // }


    // function wait(){
    //     waitScreen.bringToTop();
    //     game.add.tween(waitScreen).to( { alpha: 0.5 }, 200, Phaser.Easing.Linear.None, true, 0, 0, false);
    //     waiting = true;
    // }









    // function addMetronome(){

    //     metronome.steps = []

        

    //     var graphics = new Phaser.Graphics();
    //     graphics.beginFill(0xFF0000);
    //     graphics.drawRect(0, 0, stepWidth, 10);

    //     square = game.add.renderTexture(stepWidth, 10, 'tick');
    //     square.renderXY(graphics, 0, 0, true);

    //     // metronome.minorTick = game.add.sprite(0,0,square);

    //     for(var i=0; i<16; i++){

    //         var step = game.add.sprite(i*stepWidth, 0, square);
    //         step.visible = false;
    //         metronome.steps.push(step);

    //     }

    //     metronome.update = function(currentStep){
            
    //         this.steps.forEach(function(step, index){

    //             if(index == currentStep){
    //                 step.visible = true;
    //             }else{
    //                 step.visible = false;
    //             }
    //         });     
    //     }
    // }

 
    </script>
 
    </body>
</html>